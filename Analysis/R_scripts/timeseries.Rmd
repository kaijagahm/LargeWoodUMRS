---
title: "timeseries"
author: "Kaija Gahm"
date: "2/27/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Setup
## Libraries
```{r echo = FALSE}
source("libraries.R")
```

## Data
```{r}
load("../data/outputs/summary_all.Rda")
load("../data/outputs/summary_pool.Rda")
load("../data/outputs/summary_poolyearstratum.Rda")
load("../data/outputs/summary_stratum.Rda")
load("../data/outputs/summary_stratumpool.Rda")
load("../data/outputs/summary_yearpool.Rda")

summary_pool
```

# Time series
## Overall
### Examine by pool
```{r}
summary_yearpool %>% ggplot(aes(x = as.numeric(year), y = propwood))+
  geom_point()+
  stat_smooth(method = "loess", col = "red", se = F)+
  facet_wrap(~pool)+
  xlab("Year")+
  ylab("Proportion with LW")
```

### Tests on each pool
```{r}
head(summary_yearpool)
summary_yearpool <- summary_yearpool %>% mutate(year = as.numeric(year))

stats <- summary_yearpool %>% group_by(pool) %>% summarize(changepoint = pettitt.test(propwood)$estimate[1],
                                                           changepoint2 = pettitt.test(propwood)$estimate[2],
                                                           u_stat = pettitt.test(propwood)$statistic,
                                                           pt_pval = round(pettitt.test(propwood)$p.value, 3),
                                                           changeyear = year[changepoint] + 0.5,
                                                           changeyear2 = year[changepoint2] + 0.5,
                                                           mk_z = round(mk.test(propwood)$statistic, 3),
                                                           mk_pval = round(mk.test(propwood)$p.value, 3),
                                                           begyear = min(year),
                                                           endyear = max(year),
                                                           mn1 = round(mean(propwood[1:changepoint]), 3),
                                                           mn2 = round(mean(propwood[(changepoint + 1):n()]), 3),
                                                           mn_overall = round(mean(propwood), 3),
                                                           slope_coef = coef(lm(propwood ~ year))[2],
                                                           intercept_coef = coef(lm(propwood ~ year))[1])
stats

# this table shows results of the pettitt test and the mk test for the _overall_ dataset. It does not yet include trend analyses for subsections if a breakpoint was found.

# I have added columns for multiple changepoints. Need to add stats for trend analyses for subsections. 
```

### Add regression coefficients to stats
```{r}
stats <- stats
i <- 1
# Set stats vals to NA if not significant
for(i in 1:nrow(stats)){
  # pre- and post-changepoint regressions
  ## pre
  subdat_1 <- summary_yearpool %>% 
    filter(pool == stats$pool[i]) %>%  # select current pool
    filter(year >= stats$begyear[i] & year <= stats$changeyear[i]) # select years before the changepoint
  stats$slope_1[i] <- coef(lm(propwood ~ year, data = subdat_1))[2] # slope for pre-changepoint regression
  stats$intercept_1[i] <- coef(lm(propwood ~ year, data = subdat_1))[1] # intercept for pre-changepoint regression
  stats$mkp1[i] <- round(mk.test(subdat_1$propwood)$p.value, 3)
  
  ## post
  subdat_2 <- summary_yearpool %>% 
    filter(pool == stats$pool[i]) %>%  # select current pool
    filter(year >= stats$changeyear[i] & year <= stats$endyear[i]) # select years after the changepoint
  stats$slope_2[i] <- coef(lm(propwood ~ year, data = subdat_2))[2] # slope for post-changepoint regression
  stats$intercept_2[i] <- coef(lm(propwood ~ year, data = subdat_2))[1] # intercept for post-changepoint regression
  stats$mkp1[i] <- round(mk.test(subdat_1$propwood)$p.value, 3)
  stats$mkp2[i] <- round(mk.test(subdat_2$propwood)$p.value, 3)
  
  if(stats$pt_pval[i] >= 0.05){ # if the changepoint is non-significant...
    stats[i,c(2:4, 6:7, 12:13)] <- NA # set the changepoints, changeyears, and means to NA. 
  }else{
    stats[i, "mn_overall"] <- NA # if the p val is significant, set the overall mean to NA.
  }
  if(stats$mk_pval[i] >= 0.05){ # if the mk test is non-significant...
    stats[i, c("slope_coef", "intercept_coef")] <- NA
  }
  if(stats$mkp1[i] >= 0.05){
    stats[i, c("slope_1", "intercept_1")] <- NA
  }
  if(stats$mkp2[i] >= 0.05){
    stats[i, c("slope_2", "intercept_2")] <- NA
  } 
}

stats <- stats %>%
  mutate(ybeg_1 = slope_1*begyear + intercept_1,
         yend_1 = slope_1*changeyear + intercept_1,
         ybeg_2 = slope_2*changeyear + intercept_2,
         yend_2 = slope_2*endyear + intercept_2)

head(stats)
```


# Make plots (facetted)
```{r, warning = FALSE}
summary_yearpool %>%
  ggplot(aes(x = year, y = propwood))+
  geom_point()+
  facet_wrap(~pool)+
  theme_bw()+
  theme(panel.grid = element_blank(),
        text = element_text(size = 18))+
  ylab("Proportion of sites with large wood")+
  xlab("Year")+
  geom_vline(data = stats, aes(xintercept = changeyear), col = "red", lty = 2)+
  #geom_vline(data = stats, aes(xintercept = changeyear2), col = "red", lty = 2)+
  geom_abline(data = stats, aes(slope = slope_coef, intercept = intercept_coef),
              col = "black", lwd = 0.5)+ #overall regression
  geom_segment(data = stats, aes(x = begyear, y = mn1, xend = changeyear, yend = mn1), 
               col = "darkgrey", lty = 2)+ # mean 1
  geom_segment(data = stats, aes(x = changeyear, y = mn2, xend = endyear, yend = mn2),
               col = "darkgrey", lty = 2)+ # mean 2
  geom_segment(data = stats, aes(x = begyear, y = mn_overall, xend = endyear, yend = mn_overall),
               col = "darkgrey", lty = 2)+ # overall mean
  geom_segment(data = stats, aes(x = begyear, y = ybeg_1, xend = changeyear, yend = yend_1),
               col = "black", lwd = 1.5)+ # regression 1
  geom_segment(data = stats, aes(x = changeyear, y = ybeg_2, xend = endyear, yend = yend_2),
               col = "black", lwd = 1.5) # regression 2
```





### Make plots (cowplot)
```{r}
## FUNCTION TO CONSTRUCT GGPLOT for a given dataset
plotfun <- function(pooldata, stats){ 
  
  # DEFINE THE CURRENT POOL
  if(length(unique(pooldata$pool)) == 1){
    current_pool <- pooldata$pool[1]
  }else{
    stop('This data set contains data from more than one pool. Make sure to subset first!')
  }
  
  # GET STATS FOR THIS POOL
  current_stats <- stats %>% filter(pool == current_pool) %>% droplevels() %>% as.list() #subset the stats data frame
  
  # IF BREAKPOINT, TEST FOR LINEAR TRENDS BEFORE/AFTER BREAKPOINT
  if(current_stats$pt_pval < 0.05){ # if there is a significant breakpoint...
    mk1 <- mk.test(pooldata$propwood[1:current_stats$changepoint]) # test first part
    mk2 <- mk.test(pooldata$propwood[(current_stats$changepoint + 1):nrow(pooldata)]) # test second part
    
    mkp1 <- mk1$p.value # get first p value
    mkp2 <- mk2$p.value # get second p value
  }else{
    mkp1 <- NA # no p-value if we didn't fit the model
    mkp2 <- NA # no p-value if we didn't fit the model
  }
  
  # MAKE PLOT, WITH CONDITIONAL LAYERS
  p <- ggplot(aes(x = year, y = propwood), data = pooldata)+
    ggtitle(current_pool)+
    {if(current_stats$pt_pval < 0.05)geom_vline(xintercept = current_stats$changeyear,
                                                col = "red",
                                                lty = 2)}+ # add red line for breakpoint
    {if(current_stats$pt_pval < 0.05)geom_vline(xintercept = current_stats$changeyear2,
                                                col = "red",
                                                lty = 2)}+
    {if(current_stats$pt_pval < 0.05)geom_segment(aes(x = current_stats$begyear,
                                                      y = current_stats$mn1,
                                                      xend = current_stats$changeyear - 0.5,
                                                      yend = current_stats$mn1),
                                                  col = "darkgrey",
                                                  lty = 2)} + # add first mean
    {if(current_stats$pt_pval < 0.05)geom_segment(aes(x = current_stats$changeyear + 0.5,
                                                      y = current_stats$mn2,
                                                      xend = current_stats$endyear,
                                                      yend = current_stats$mn2),
                                                  col = "darkgrey",
                                                  lty = 2)}+ # add second mean
    {if(current_stats$mk_pval < 0.05)geom_smooth(method = "lm", 
                                                 se = FALSE, 
                                                 col = "black",
                                                 lwd = 0.5)}+
    {if(current_stats$pt_pval >= 0.05 & 
        current_stats$mk_pval >= 0.05)geom_segment(aes(x = current_stats$begyear,
                                                       y = mean(propwood),
                                                       xend = current_stats$endyear,
                                                       yend = mean(propwood)),
                                                   col = "darkgrey",
                                                   lty = 2)}+ # add a plain mean if neither test is sig.
    {if(!is.na(mkp1) & 
        mkp1 < 0.05)geom_smooth(data = pooldata[1:current_stats$changepoint,],
                                method = "lm",
                                se = F,
                                col = "black")}+
    {if(!is.na(mkp2) & 
        mkp2 < 0.05)geom_smooth(data = pooldata[(current_stats$changepoint + 1):nrow(pooldata),],
                                method = "lm",
                                se = F,
                                col = "black")}+
    geom_point(size = 0.75)+
    theme(axis.title.x = element_blank(),
          axis.title.y = element_blank())+
    theme_minimal()
    return(p)
}

pools <- summary_yearpool$pool %>% unique() # get a vector of unique pools

pool_plots <- vector(mode = "list", length = length(pools))

for(i in 1:length(pools)){ # loop through the pools to make plots
  subset <- summary_yearpool %>% filter(pool == pools[i])
  pt <- plotfun(pooldata = subset, stats = stats)
  pool_plots[[i]] <- pt
}

pools <- cowplot::plot_grid(plotlist = pool_plots)
pools
#ggsave(pools, filename = "../data/outputs/pools_plots.png", width = 11, height = 6)
```

## By aquatic areas
### Tests on each aquatic area within each pool
#### Calculate stats
```{r}
head(summary_poolyearstratum)
summary_poolyearstratum <- summary_poolyearstratum %>% mutate(year = as.numeric(year))

stats_stratum <- summary_poolyearstratum %>% 
  group_by(pool, stratum) %>%
  filter(n() >= 3) %>%
  summarize(changepoint = pettitt.test(propwood)$estimate[1], # first changepoint if more than one
            changepoint2 = pettitt.test(propwood)$estimate[2],
            u_stat = pettitt.test(propwood)$statistic[1],
            pt_pval = round(pettitt.test(propwood)$p.value[1], 3),
            changeyear = year[changepoint] + 0.5,
            changeyear2 = year[changepoint2] + 0.5,
            mk_z = round(mk.test(propwood)$statistic, 3),
            mk_pval = round(mk.test(propwood)$p.value, 3),
            begyear = min(year),
            endyear = max(year),
            mn1 = round(mean(propwood[1:changepoint]), 3),
            mn2 = round(mean(propwood[(changepoint + 1):n()]), 3)) 
  
stats_stratum
```

#### Plot for each
```{r}
plotfun_strata <- function(poolstratumdata, stats){
  
}



plotfun_strata <- function(poolstratumdata, stats){
  # Define the current pool
  if(length(unique(poolstratumdata$pool)) == 1){
    current_pool <- poolstratumdata$pool[1]
  }else{
    stop('This data set contains data from more than one pool. Make sure to subset first!')
  }
  
   # Define the current stratum
  if(length(unique(poolstratumdata$stratum)) == 1){
    current_stratum <- poolstratumdata$stratum[1]
  }else{
    stop('This data set contains data from more than one stratum. Make sure to subset first!')
  }
  
  # Get stats for this pool and stratum
  current_stats <- stats %>% 
    filter(pool == current_pool, stratum == current_stratum) %>%
    droplevels() %>% as.list() # subset the stats data frame
  
  # If breakpoint, test for linear trends before/after breakpoint
  if(current_stats$pt_pval < 0.05){ # if there is a significant breakpoint...
    mk1 <- mk.test(poolstratumdata$propwood[1:current_stats$changepoint]) # test first part
    mk2 <- mk.test(poolstratumdata$propwood[(current_stats$changepoint + 1):nrow(poolstratumdata)]) # test second part
    
    mkp1 <- mk1$p.value # get first p value
    mkp2 <- mk2$p.value # get second p value
  }else{
    mkp1 <- NA # no p-value if we didn't fit the model
    mkp2 <- NA # no p-value if we didn't fit the model
  }
  
  # Make plot, with conditional layers
  p <- ggplot(aes(x = year, y = propwood), data = poolstratumdata)+
    ggtitle(paste(current_pool, current_stratum))+
    {if(current_stats$pt_pval < 0.05)geom_vline(xintercept = current_stats$changeyear,
                                                col = "red",
                                                lty = 2)}+ # add red line for breakpoint
    {if(current_stats$pt_pval < 0.05)geom_segment(aes(x = current_stats$begyear,
                                                      y = current_stats$mn1,
                                                      xend = current_stats$changeyear - 0.5,
                                                      yend = current_stats$mn1),
                                                  col = "darkgrey",
                                                  lty = 2)} + # add first mean
    {if(current_stats$pt_pval < 0.05)geom_segment(aes(x = current_stats$changeyear + 0.5,
                                                      y = current_stats$mn2,
                                                      xend = current_stats$endyear,
                                                      yend = current_stats$mn2),
                                                  col = "darkgrey",
                                                  lty = 2)}+ # add second mean
    {if(current_stats$mk_pval < 0.05)geom_smooth(method = "lm", 
                                                 se = FALSE, 
                                                 col = "black",
                                                 lwd = 0.5)}+
    {if(current_stats$pt_pval >= 0.05 & 
        current_stats$mk_pval >= 0.05)geom_segment(aes(x = current_stats$begyear,
                                                       y = mean(propwood),
                                                       xend = current_stats$endyear,
                                                       yend = mean(propwood)),
                                                   col = "darkgrey",
                                                   lty = 2)}+ # add a plain mean if neither test is sig.
    {if(!is.na(mkp1) & 
        mkp1 < 0.05)geom_smooth(data = poolstratumdata[1:current_stats$changepoint,],
                                method = "lm",
                                se = F,
                                col = "black")}+
    {if(!is.na(mkp2) & 
        mkp2 < 0.05)geom_smooth(data = poolstratumdata[(current_stats$changepoint + 1):nrow(poolstratumdata),],
                                method = "lm",
                                se = F,
                                col = "black")}+
    geom_point(size = 0.75)+
    theme(axis.title.x = element_blank(),
          axis.title.y = element_blank())
    return(p)
}

# get unique combos of pools and strata
poolstrata <- stats_stratum %>%
  dplyr::select(pool, stratum) %>%
  distinct()

plots_list <- vector(mode = "list", length = nrow(poolstrata))
for(i in 1:nrow(poolstrata)){ # loop through the pool/stratum combos
  subset <- summary_poolyearstratum %>% filter(pool == poolstrata$pool[i], stratum == poolstrata$stratum[i])
  pt <- plotfun_strata(poolstratumdata = subset, stats = stats_stratum)
  plots_list[[i]] <- pt
}

strata_plots <- cowplot::plot_grid(plotlist = plots_list)
ggsave(strata_plots, filename = "../data/outputs/strata_plots.png", width = 11, height = 7)
```

